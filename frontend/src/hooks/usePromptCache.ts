import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { supabase } from '@/integrations/client';
import type { PromptType, PromptCache } from '@/lib/types';
import { toast } from 'sonner';
import axios from "axios";

interface GeneratePromptParams {
  projectId: string;
  promptType: PromptType;
  projectData: {
    title: string;
    description: string;
    problem_statement: string;
    features: string[];
    tech_stack: string[];
    system_design_overview: string | null;
  };
}

// ðŸ”¥ Use ENV instead of localhost
const API_URL = import.meta.env.VITE_API_URL;

function getSessionId(): string {
  let sessionId = localStorage.getItem('promptforge_session');
  if (!sessionId) {
    sessionId = crypto.randomUUID();
    localStorage.setItem('promptforge_session', sessionId);
  }
  return sessionId;
}

// =======================
// Cached prompt (single)
// =======================
export function useCachedPrompt(projectId: string, promptType: PromptType) {
  return useQuery({
    queryKey: ['prompt-cache', projectId, promptType],
    queryFn: async (): Promise<PromptCache | null> => {
      const { data, error } = await supabase
        .from('prompt_cache')
        .select('*')
        .eq('project_id', projectId)
        .eq('prompt_type', promptType)
        .gt('expires_at', new Date().toISOString())
        .single();

      if (error && error.code !== 'PGRST116') {
        console.error('Error fetching cached prompt:', error);
        return null;
      }

      return data as unknown as PromptCache | null;
    },
    staleTime: 5 * 60 * 1000,
    gcTime: 30 * 60 * 1000,
  });
}

// =======================
// All prompts for project
// =======================
export function useProjectPrompts(projectId: string) {
  return useQuery({
    queryKey: ['project-prompts', projectId],
    queryFn: async (): Promise<PromptCache[]> => {
      const { data, error } = await supabase
        .from('prompt_cache')
        .select('*')
        .eq('project_id', projectId)
        .gt('expires_at', new Date().toISOString());

      if (error) {
        console.error('Error fetching project prompts:', error);
        return [];
      }

      return data as unknown as PromptCache[];
    },
    staleTime: 2 * 60 * 1000,
  });
}

// =======================
// Generate prompt mutation
// =======================
export function useGeneratePrompt() {
  const queryClient = useQueryClient();

  return useMutation<PromptCache, Error, GeneratePromptParams>({
    mutationFn: async ({ projectId, promptType, projectData }) => {
      const sessionId = getSessionId();

      try {
        const res = await axios.post(
          `${API_URL}/prompts/${projectId}/generate`,
          {
            promptType,
            projectData,
            sessionId
          }
        );

        return res.data as PromptCache;

      } catch (err: any) {
        if (err.response?.status === 429) {
          throw new Error('Rate limit exceeded. Please try again later.');
        }

        if (err.response?.status === 402) {
          throw new Error('AI usage limit reached. Please upgrade.');
        }

        throw new Error(
          err.response?.data?.message || 'Failed to generate prompt'
        );
      }
    },

    onSuccess: (data, variables) => {
      queryClient.setQueryData(
        ['prompt-cache', variables.projectId, variables.promptType],
        data
      );

      queryClient.invalidateQueries({
        queryKey: ['project-prompts', variables.projectId]
      });

      queryClient.invalidateQueries({
        queryKey: ['rate-limit-status']
      });

      queryClient.invalidateQueries({
        queryKey: ['all-rate-limits']
      });

      toast.success('Prompt generated successfully');
    },

    onError: (error) => {
      toast.error(error.message || 'Failed to generate prompt');
    }
  });
}

// =======================
// Copy
// =======================
export function useCopyToClipboard() {
  return useMutation({
    mutationFn: async (content: string) => {
      await navigator.clipboard.writeText(content);
    },
    onSuccess: () => {
      toast.success('Copied to clipboard');
    },
    onError: () => {
      toast.error('Failed to copy');
    }
  });
}

// =======================
// Export markdown
// =======================
export function useExportMarkdown() {
  return useMutation({
    mutationFn: async ({ title, prompts }: { title: string; prompts: PromptCache[] }) => {
      const content = prompts
        .map(p => `## ${p.prompt_type.toUpperCase()}\n\n${p.prompt_content}`)
        .join('\n\n---\n\n');

      const markdown = `# ${title} - AI Prompts

Generated by PromptForge

---

${content}`;

      const blob = new Blob([markdown], { type: 'text/markdown' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `${title.toLowerCase().replace(/\s+/g, '-')}-prompts.md`;
      a.click();
      URL.revokeObjectURL(url);
    },
    onSuccess: () => {
      toast.success('Exported as Markdown');
    },
    onError: () => {
      toast.error('Failed to export');
    }
  });
}
