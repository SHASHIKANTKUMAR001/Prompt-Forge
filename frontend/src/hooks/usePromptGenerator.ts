import { useState, useCallback } from "react";
import type { PromptType, PromptCache } from "@/lib/types";
import { toast } from "sonner";
import { useAuth } from "@clerk/clerk-react";   // ✅ added Clerk import

// API base URL (auto switches between dev & prod)
const API_URL = import.meta.env.VITE_API_URL;

// Generate or retrieve session ID for rate limiting
function getSessionId(): string {
  let sessionId = localStorage.getItem("promptforge_session");
  if (!sessionId) {
    sessionId = crypto.randomUUID();
    localStorage.setItem("promptforge_session", sessionId);
  }
  return sessionId;
}

export function usePromptGenerator() {
  const [isGenerating, setIsGenerating] = useState(false);
  const [generatedPrompts, setGeneratedPrompts] = useState<Record<string, PromptCache>>({});
  const { getToken } = useAuth();   // ✅ get Clerk token function

  const generatePrompt = useCallback(
    async (
      projectId: string,
      promptType: PromptType,
      projectData: {
        title: string;
        description: string;
        problem_statement: string;
        features: string[];
        tech_stack: string[];
        system_design_overview: string | null;
      }
    ): Promise<PromptCache | null> => {
      setIsGenerating(true);

      try {
        const sessionId = getSessionId();
        const token = await getToken({ template: "default" });   // ✅ fetch Clerk JWT

        const res = await fetch(`${API_URL}/prompts/${projectId}/generate`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Authorization: token ? `Bearer ${token}` : "",   // ✅ attach token
          },
          body: JSON.stringify({
            promptType,
            projectData,
            sessionId,
          }),
        });

        if (!res.ok) {
          if (res.status === 401) {
            toast.error("You must sign in to generate prompts");
            window.location.href = "/sign-in";   // ✅ redirect if not signed in
          } else if (res.status === 429) {
            toast.error("Rate limit exceeded");
          } else if (res.status === 402) {
            toast.error("AI usage limit reached");
          } else {
            toast.error("Failed to generate prompt");
          }
          throw new Error("Generation failed");
        }

        const prompt = (await res.json()) as PromptCache;

        setGeneratedPrompts((prev) => ({
          ...prev,
          [`${projectId}-${promptType}`]: prompt,
        }));

        toast.success("Prompt generated successfully");
        return prompt;
      } catch (error) {
        console.error("Prompt generation error:", error);
        toast.error("Server not reachable");
        return null;
      } finally {
        setIsGenerating(false);
      }
    },
    [getToken]   // ✅ include getToken in dependencies
  );

  const copyToClipboard = useCallback(async (content: string) => {
    try {
      await navigator.clipboard.writeText(content);
      toast.success("Copied to clipboard");
    } catch {
      toast.error("Failed to copy");
    }
  }, []);

  const exportAsMarkdown = useCallback((title: string, prompts: PromptCache[]) => {
    const content = prompts
      .map((p) => `## ${p.prompt_type.toUpperCase()}\n\n${p.prompt_content}`)
      .join("\n\n---\n\n");

    const markdown = `# ${title} - AI Prompts

Generated by PromptForge

---

${content}`;

    const blob = new Blob([markdown], { type: "text/markdown" });
    const url = URL.createObjectURL(blob);

    const a = document.createElement("a");
    a.href = url;
    a.download = `${title.toLowerCase().replace(/\s+/g, "-")}-prompts.md`;
    a.click();

    URL.revokeObjectURL(url);
    toast.success("Exported as Markdown");
  }, []);

  return {
    isGenerating,
    generatedPrompts,
    generatePrompt,
    copyToClipboard,
    exportAsMarkdown,
  };
}
